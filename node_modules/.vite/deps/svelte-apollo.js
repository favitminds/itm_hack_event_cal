import {
  ApolloError
} from "./chunk-AT4EUU6P.js";
import {
  readable
} from "./chunk-OX7W4OIX.js";
import "./chunk-X7HCJ7ZS.js";
import {
  getContext,
  onMount,
  setContext
} from "./chunk-SKZ77QWX.js";
import "./chunk-LYBY5SRM.js";
import "./chunk-2B2CG5KL.js";

// node_modules/svelte-apollo/dist/svelte-apollo.js
var CLIENT = typeof Symbol !== "undefined" ? Symbol("client") : "@@client";
function getClient() {
  const client = getContext(CLIENT);
  if (!client) {
    throw new Error("ApolloClient has not been set yet, use setClient(new ApolloClient({ ... })) to define it");
  }
  return client;
}
function setClient(client) {
  setContext(CLIENT, client);
}
function mutation(mutation2, initialOptions = {}) {
  const client = getClient();
  return (options) => client.mutate({ mutation: mutation2, ...initialOptions, ...options });
}
function observableToReadable(observable, initialValue = {
  loading: true,
  data: void 0,
  error: void 0
}) {
  const store = readable(initialValue, (set) => {
    const skipDuplicate = (initialValue == null ? void 0 : initialValue.data) !== void 0;
    let skipped = false;
    const subscription = observable.subscribe((result) => {
      if (skipDuplicate && !skipped) {
        skipped = true;
        return;
      }
      if (result.errors) {
        const error = new ApolloError({ graphQLErrors: result.errors });
        set({ loading: false, data: void 0, error });
      } else {
        set({ loading: false, data: result.data, error: void 0 });
      }
    }, (error) => set({
      loading: false,
      data: void 0,
      error: error && "message" in error ? error : new Error(error)
    }));
    return () => subscription.unsubscribe();
  });
  return store;
}
var extensions = [
  "fetchMore",
  "getCurrentResult",
  "getLastError",
  "getLastResult",
  "isDifferentFromLastResult",
  "refetch",
  "resetLastResults",
  "resetQueryStoreErrors",
  "result",
  "setOptions",
  "setVariables",
  "startPolling",
  "stopPolling",
  "subscribeToMore",
  "updateQuery"
];
function observableQueryToReadable(query2, initialValue) {
  const store = observableToReadable(query2, initialValue);
  for (const extension of extensions) {
    store[extension] = query2[extension].bind(query2);
  }
  return store;
}
var restoring = typeof WeakSet !== "undefined" ? /* @__PURE__ */ new WeakSet() : /* @__PURE__ */ new Set();
function restore(query2, options) {
  const client = getClient();
  restoring.add(client);
  afterHydrate(() => restoring.delete(client));
  client.writeQuery({ query: query2, ...options });
}
function afterHydrate(callback) {
  try {
    onMount(callback);
  } catch (_error) {
    setTimeout(callback, 1);
  }
}
function query(query2, options = {}) {
  const client = getClient();
  const queryOptions = { ...options, query: query2 };
  let initialValue;
  if (restoring.has(client)) {
    try {
      initialValue = client.readQuery(queryOptions) || void 0;
    } catch (err) {
    }
  }
  const observable = client.watchQuery(queryOptions);
  const store = observableQueryToReadable(observable, initialValue !== void 0 ? {
    data: initialValue
  } : void 0);
  return store;
}
function subscribe(query2, options = {}) {
  const client = getClient();
  const observable = client.subscribe({ query: query2, ...options });
  return observableToReadable(observable);
}
export {
  getClient,
  mutation,
  observableToReadable,
  query,
  restore,
  setClient,
  subscribe
};
//# sourceMappingURL=svelte-apollo.js.map
