import "./chunk-2B2CG5KL.js";

// node_modules/@kitql/helper/index.mjs
function logGreen(str) {
  return `\x1B[32m${str}\x1B[37m\x1B[0m`;
}
function logMagneta(str) {
  return `\x1B[35m${str}\x1B[37m\x1B[0m`;
}
function logRed(str) {
  return `\x1B[31m${str}\x1B[37m\x1B[0m`;
}
function logCyan(str) {
  return `\x1B[36m${str}\x1B[37m\x1B[0m`;
}
function logYellow(str) {
  return `\x1B[33m${str}\x1B[37m\x1B[0m`;
}
var Log = class {
  constructor(toolName, options = {}) {
    var _a, _b, _c;
    this.toolName = toolName;
    this.levelsToShow = (_a = options.levelsToShow) !== null && _a !== void 0 ? _a : 2;
    this.withDate = (_b = options.withDate) !== null && _b !== void 0 ? _b : null;
    this.prefixEmoji = (_c = options.prefixEmoji) !== null && _c !== void 0 ? _c : "";
  }
  setLevel(logLevel) {
    this.levelsToShow = logLevel;
  }
  buildStr(msg, withError, withSuccess, indent) {
    const table = [];
    table.push(`${logMagneta(`[${this.toolName}]`)}`);
    if (this.withDate === "dateTime") {
      table.push(`${logMagneta(`[${(/* @__PURE__ */ new Date()).toISOString()}]`)}`);
    } else if (this.withDate === "time") {
      table.push(`${logMagneta(`[${(/* @__PURE__ */ new Date()).toISOString().split("T")[1]}]`)}`);
    }
    if (withError) {
      table.push(`❌`);
    } else if (withSuccess) {
      table.push(`✅`);
    } else {
      table.push(`${this.prefixEmoji}`);
    }
    table.push(indent);
    table.push(` ${msg}`);
    return table.join("");
  }
  info(msg, conf = { level: 0, withSuccess: false }) {
    var _a, _b;
    const level = (_a = conf.level) !== null && _a !== void 0 ? _a : 0;
    const withSuccess = (_b = conf.withSuccess) !== null && _b !== void 0 ? _b : false;
    if (this.levelsToShow !== null && level <= this.levelsToShow) {
      const indent = " ".repeat(level);
      console.info(this.buildStr(msg, false, withSuccess, indent));
    }
  }
  success(msg, conf = { level: 0 }) {
    this.info(msg, { level: conf.level, withSuccess: true });
  }
  error(msg) {
    console.error(this.buildStr(msg, true, false, ""));
  }
};
function sortObject(object) {
  const sortedObj = {};
  const keys = Object.keys(object);
  if (keys.length === 0) {
    return object;
  }
  keys.sort((key1, key2) => {
    key1 = key1.toLowerCase(), key2 = key2.toLowerCase();
    if (key1 < key2)
      return -1;
    if (key1 > key2)
      return 1;
    return 0;
  });
  for (const index in keys) {
    const key = keys[index];
    if (typeof object[key] == "object" && !Array.isArray(object[key]) && object[key]) {
      sortedObj[key] = sortObject(object[key]);
    } else {
      sortedObj[key] = object[key];
    }
  }
  return sortedObj;
}
function stry(obj, space = 2) {
  if (obj === null) {
    return null;
  }
  if (obj === void 0) {
    return void 0;
  }
  const ordered = sortObject(obj);
  return JSON.stringify(ordered, null, space);
}
async function sleep(ms) {
  if (ms <= 0) {
    return;
  }
  return new Promise((resolve) => setTimeout(resolve, ms));
}

// node_modules/@kitql/client/index.mjs
var InMemoryCache = class {
  constructor() {
    this.cacheIndexes = {};
    this.cacheData = {};
  }
  set(operationKey, data) {
    const v = stry(data.variables, 0);
    const fullKey = stry({ k: operationKey, v }, 0);
    if (this.cacheIndexes[operationKey] !== void 0) {
      if (this.cacheData[fullKey] === void 0) {
        this.cacheIndexes[operationKey].push(v);
      }
    } else {
      this.cacheIndexes[operationKey] = [v];
    }
    this.cacheData[fullKey] = data;
  }
  get(operationKey, variables = null) {
    const v = stry(variables, 0);
    const fullKey = stry({ k: operationKey, v }, 0);
    return this.cacheData[fullKey];
  }
  remove(operationKey, variables = null, allOperationKey = true) {
    let nbDeleted = 0;
    if (this.cacheIndexes[operationKey] !== void 0) {
      if (allOperationKey) {
        const keys = this.cacheIndexes[operationKey];
        for (let i = 0; i < keys.length; i++) {
          const v = keys[i];
          const fullKey = stry({ k: operationKey, v }, 0);
          delete this.cacheData[fullKey];
          nbDeleted++;
        }
        delete this.cacheIndexes[operationKey];
      } else {
        const v = stry(variables, 0);
        const fullKey = stry({ k: operationKey, v }, 0);
        if (this.cacheData[fullKey] !== void 0) {
          delete this.cacheData[fullKey];
          this.cacheIndexes[operationKey] = this.cacheIndexes[operationKey].filter((c) => c !== v);
          nbDeleted = 1;
        }
      }
    }
    return nbDeleted;
  }
};
var LocalStorageCache = class {
  set(operationKey, data) {
    const v = stry(data.variables, 0);
    const fullKey = stry({ k: operationKey, v }, 0);
    const rawIndexes = window.localStorage.getItem(operationKey);
    if (rawIndexes) {
      const indexes = JSON.parse(rawIndexes);
      if (!window.localStorage.getItem(fullKey)) {
        indexes.push(v);
        window.localStorage.setItem(operationKey, JSON.stringify(indexes));
      }
    } else {
      window.localStorage.setItem(operationKey, JSON.stringify([v]));
    }
    window.localStorage.setItem(fullKey, stry(data, 0));
  }
  get(operationKey, variables = null) {
    const v = stry(variables, 0);
    const fullKey = stry({ k: operationKey, v }, 0);
    const data = window.localStorage.getItem(fullKey);
    if (!data)
      return void 0;
    return JSON.parse(data);
  }
  remove(operationKey, variables = null, allOperationKey = true) {
    let nbDeleted = 0;
    const rawIndexes = window.localStorage.getItem(operationKey);
    if (rawIndexes) {
      const indexes = JSON.parse(rawIndexes);
      if (allOperationKey) {
        const keysToDelete = indexes.map((v) => stry({ k: operationKey, v }, 0));
        nbDeleted = keysToDelete.length;
        window.localStorage.removeItem(operationKey);
        keysToDelete.forEach((key) => window.localStorage.removeItem(key));
      } else {
        const v = stry(variables, 0);
        const fullKey = stry({ k: operationKey, v }, 0);
        window.localStorage.removeItem(fullKey);
        const newIndexes = indexes.filter((c) => c !== v);
        window.localStorage.setItem(operationKey, JSON.stringify(newIndexes));
        nbDeleted = 1;
      }
    }
    return nbDeleted;
  }
};
function printBlockString(n) {
  return '"""\n' + JSON.stringify(n).slice(1, -1) + '\n"""';
}
var r = JSON.stringify;
function print(r$1) {
  if (Array.isArray(r$1)) {
    return r$1.map(print);
  } else if (null == r$1 || "object" != typeof r$1) {
    return r$1 ? "" + r$1 : "";
  }
  switch (r$1.kind) {
    case "OperationDefinition":
      var t = join([r$1.operation, print(r$1.name) + wrap("(", join(print(r$1.variableDefinitions), ", "), ")"), join(print(r$1.directives), " ")], " ");
      return ("query" === t ? "" : t + " ") + print(r$1.selectionSet);
    case "VariableDefinition":
      return print(r$1.variable) + ": " + print(r$1.type) + wrap(" = ", print(r$1.defaultValue)) + wrap(" ", join(print(r$1.directives), " "));
    case "Field":
      return join([wrap("", print(r$1.alias), ": ") + print(r$1.name) + wrap("(", join(print(r$1.arguments), ", "), ")"), join(print(r$1.directives), " "), print(r$1.selectionSet)], " ");
    case "StringValue":
      return r$1.isBlockString ? printBlockString(r$1.value) : r(r$1.value);
    case "BooleanValue":
      return r$1.value ? "true" : "false";
    case "NullValue":
      return "null";
    case "IntValue":
    case "FloatValue":
    case "EnumValue":
    case "Name":
      return r$1.value;
    case "ListValue":
      return "[" + join(print(r$1.values), ", ") + "]";
    case "ObjectValue":
      return "{" + join(print(r$1.fields), ", ") + "}";
    case "ObjectField":
      return r$1.name.value + ": " + print(r$1.value);
    case "Variable":
      return "$" + r$1.name.value;
    case "Document":
      return join(print(r$1.definitions), "\n\n") + "\n";
    case "SelectionSet":
      return block(print(r$1.selections));
    case "Argument":
      return r$1.name.value + ": " + print(r$1.value);
    case "FragmentSpread":
      return "..." + print(r$1.name) + wrap(" ", join(print(r$1.directives), " "));
    case "InlineFragment":
      return join(["...", wrap("on ", print(r$1.typeCondition)), join(print(r$1.directives), " "), print(r$1.selectionSet)], " ");
    case "FragmentDefinition":
      return "fragment " + r$1.name.value + wrap("(", join(print(r$1.variableDefinitions), ", "), ")") + " on " + print(r$1.typeCondition) + " " + wrap("", join(print(r$1.directives), " "), " ") + print(r$1.selectionSet);
    case "Directive":
      return "@" + r$1.name.value + wrap("(", join(print(r$1.arguments), ", "), ")");
    case "NamedType":
      return r$1.name.value;
    case "ListType":
      return "[" + print(r$1.type) + "]";
    case "NonNullType":
      return print(r$1.type) + "!";
    default:
      return "";
  }
}
var join = function(e, n) {
  return e && e.filter(function(e2) {
    return e2;
  }).join(n || "") || "";
};
var block = function(e) {
  return wrap("{\n  ", join(e, "\n").replace(/\n/g, "\n  "), "\n}");
};
var wrap = function(e, n, r2) {
  return n ? e + n + (r2 || "") : "";
};
var RequestStatus;
(function(RequestStatus2) {
  RequestStatus2["NEVER"] = "NEVER";
  RequestStatus2["LOADING"] = "LOADING";
  RequestStatus2["DONE"] = "DONE";
})(RequestStatus || (RequestStatus = {}));
var RequestFrom;
(function(RequestFrom2) {
  RequestFrom2["NODATA"] = "NODATA";
  RequestFrom2["NETWORK"] = "NETWORK";
  RequestFrom2["SSR"] = "SSR";
  RequestFrom2["CACHE"] = "CACHE";
})(RequestFrom || (RequestFrom = {}));
var ResponseResultType;
(function(ResponseResultType2) {
  ResponseResultType2["Query"] = "Query";
  ResponseResultType2["Mutation"] = "Mutation";
})(ResponseResultType || (ResponseResultType = {}));
var defaultStoreValue = {
  status: RequestStatus.NEVER,
  isFetching: false,
  date: (/* @__PURE__ */ new Date()).getTime(),
  operationName: "???",
  operationType: ResponseResultType.Query,
  variables: null,
  data: null,
  errors: null,
  from: RequestFrom.NODATA,
  isOutdated: false
};
var KitQLClient = class {
  constructor(options) {
    var _a, _b;
    const { url, cacheMs, credentials, headers, policy, headersContentType, endpointNetworkDelayMs, endpointSSRDelayMs } = options !== null && options !== void 0 ? options : {};
    this.url = url;
    this.policy = policy !== null && policy !== void 0 ? policy : "cache-first";
    this.headers = headers !== null && headers !== void 0 ? headers : {};
    this.cacheMs = cacheMs !== null && cacheMs !== void 0 ? cacheMs : 1e3 * 60 * 3;
    this.credentials = credentials;
    this.headersContentType = headersContentType !== null && headersContentType !== void 0 ? headersContentType : "application/graphql+json";
    this.logType = (_a = options.logType) !== null && _a !== void 0 ? _a : [];
    this.cacheData = (_b = options.cacheImplementation) !== null && _b !== void 0 ? _b : new InMemoryCache();
    this.endpointNetworkDelayMs = endpointNetworkDelayMs !== null && endpointNetworkDelayMs !== void 0 ? endpointNetworkDelayMs : 0;
    this.endpointSSRDelayMs = endpointSSRDelayMs !== null && endpointSSRDelayMs !== void 0 ? endpointSSRDelayMs : 0;
    this.log = new Log("KitQL Client");
    this.log.info("This lib was deprecated check https://www.kitql.dev/docs/migrating-to-0.7.0 to upgrade.");
  }
  getHeaders() {
    return this.headers;
  }
  setHeaders(headers) {
    this.headers = headers;
  }
  logOperation(from, operation, variables = null) {
    this.log.info(
      // `${logCyan('Mode:')} ` +
      // 	`${logGreen(browser ? 'browser' : 'server')}, ` +
      `${logCyan("From:")} ${logGreen(from)}, ${new Array(7 - from.length + 1).join(" ")}${logCyan("Operation:")} ${logGreen(operation)}${variables ? `, ${logCyan("Variables:")} ${logGreen(variables)}` : ``}`
    );
  }
  getLogsStatements(browser) {
    const browserAndWantLog = browser && this.logType.includes("client");
    const serverAndWantLog = !browser && this.logType.includes("server");
    const logOp = this.logType.includes("operation") && (browserAndWantLog !== null && browserAndWantLog !== void 0 ? browserAndWantLog : serverAndWantLog);
    const logOpVar = this.logType.includes("operationAndvariables") && (browserAndWantLog !== null && browserAndWantLog !== void 0 ? browserAndWantLog : serverAndWantLog);
    const logRawResult = this.logType.includes("rawResult") && (browserAndWantLog !== null && browserAndWantLog !== void 0 ? browserAndWantLog : serverAndWantLog);
    return { logOp, logOpVar, logRawResult };
  }
  requestCache({ variables, operationName, cacheMs, browser }) {
    const logStatements = this.getLogsStatements(browser);
    if (browser) {
      const cachedData = this.cacheData.get(operationName, variables);
      if (cachedData !== void 0) {
        const xMs = (/* @__PURE__ */ new Date()).getTime() - cachedData.date;
        if (xMs < (cacheMs !== null && cacheMs !== void 0 ? cacheMs : this.cacheMs)) {
          if (logStatements.logOpVar) {
            this.logOperation(RequestFrom.CACHE, operationName, stry(variables, 0));
          } else if (logStatements.logOp) {
            this.logOperation(RequestFrom.CACHE, operationName);
          }
          return { ...cachedData, from: RequestFrom.CACHE, isOutdated: false };
        }
        return { ...cachedData, from: RequestFrom.CACHE, isOutdated: true };
      }
    }
    return null;
  }
  async request({ skFetch, document, variables, operationName, operationType, browser }) {
    const logStatements = this.getLogsStatements(browser);
    if (!browser && !skFetch) {
      this.log.error(`I think that either:
	${logRed(`1/`)} you forgot to provide \`${logYellow(`fetch`)}\`! As we are in SSR here. 
	   It should be something like:

	<script context="module" lang="ts">
	  export async function load({ ${logYellow(`fetch`)} }) {
	    ${logYellow("await")} ${logCyan(operationName)}.queryLoad({ ${logYellow(`fetch`)}, variables: { ... } });
	    return {};
	  }
	<\/script>

	${logRed(`2/`)} you should run this in a browser only.`);
    }
    const fetchToUse = skFetch ? skFetch : fetch;
    const dataToReturn = {
      date: (/* @__PURE__ */ new Date()).getTime(),
      operationName,
      operationType,
      variables,
      from: RequestFrom.NETWORK,
      data: null,
      errors: null,
      isOutdated: false
    };
    try {
      const res = await fetchToUse(this.url, {
        method: "POST",
        credentials: this.credentials,
        headers: { ...this.headers, "Content-Type": this.headersContentType },
        body: JSON.stringify({
          query: print(document),
          variables
        })
      });
      if (res.url === "") {
        dataToReturn.from = RequestFrom.SSR;
        await sleep(this.endpointSSRDelayMs);
      } else {
        await sleep(this.endpointNetworkDelayMs);
      }
      if (logStatements.logOpVar) {
        this.logOperation(dataToReturn.from, operationName, stry(variables, 0));
      } else if (logStatements.logOp) {
        this.logOperation(dataToReturn.from, operationName);
      }
      if (res.status !== 200) {
        if (res.statusText === "") {
          dataToReturn.errors = [new Error(`${res.status} - ${await res.text()}`)];
        } else {
          dataToReturn.errors = [new Error(`${res.status} - ${res.statusText}`)];
        }
        return dataToReturn;
      }
      const dataJson = await res.json();
      if (logStatements.logRawResult) {
        this.log.info(`${logCyan("dataJson:")} ${stry(dataJson, 0)}`);
      }
      if (dataJson.errors && dataJson.errors.length > 0) {
        dataToReturn.errors = dataJson.errors;
        return dataToReturn;
      }
      dataToReturn.data = dataJson.data;
      if (browser) {
        this.cacheData.set(operationName, dataToReturn);
      }
      return dataToReturn;
    } catch (errors) {
      dataToReturn.errors = [errors];
      return dataToReturn;
    }
  }
  cacheRemove(operationKey, params) {
    const nbDeleted = this.cacheData.remove(operationKey, params.variables, params.allOperationKey);
    this.logInfo(operationKey, "ResetCache", nbDeleted.toString());
    return nbDeleted;
  }
  logInfo(operationName, key, value) {
    const browserAndWantLog = this.logType.includes("client");
    if (browserAndWantLog) {
      this.log.info(`${logCyan(`${key}:`)} ${logGreen(value)}, ${logCyan("Operation:")} ${logGreen(operationName)}`);
    }
  }
  cacheUpdate(operationKey, data, params) {
    const dataCached = this.cacheData.get(operationKey, params.variables);
    if (dataCached) {
      const toReturn = { ...dataCached, data, variables: params.variables };
      this.cacheData.set(operationKey, toReturn);
      return toReturn;
    }
    return void 0;
  }
};
function isLoading(stores) {
  if (Array.isArray(stores)) {
    return stores.some((store) => store.status === RequestStatus.LOADING);
  }
  return stores.status === RequestStatus.LOADING;
}
export {
  InMemoryCache,
  KitQLClient,
  LocalStorageCache,
  RequestFrom,
  RequestStatus,
  ResponseResultType,
  defaultStoreValue,
  isLoading
};
//# sourceMappingURL=@kitql_client.js.map
