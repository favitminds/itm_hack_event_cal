import "./chunk-XML7UXAA.js";
import {
  dequal
} from "./chunk-KKDTFIKJ.js";
import {
  derived,
  writable
} from "./chunk-OX7W4OIX.js";
import "./chunk-X7HCJ7ZS.js";
import {
  SvelteComponentDev,
  add_location,
  append_hydration_dev,
  assign,
  children,
  claim_element,
  claim_text,
  component_subscribe,
  compute_rest_props,
  create_slot,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_update,
  get_store_value,
  globals,
  init,
  insert_hydration_dev,
  listen_dev,
  noop,
  run_all,
  safe_not_equal,
  select_option,
  select_options,
  setContext,
  set_attributes,
  set_data_maybe_contenteditable_dev,
  text,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots,
  validate_store
} from "./chunk-SKZ77QWX.js";
import "./chunk-LYBY5SRM.js";
import "./chunk-2B2CG5KL.js";

// node_modules/svelte-forms-lib/lib/components/key.js
var key = {};

// node_modules/svelte-forms-lib/lib/util.js
function subscribeOnce(observable) {
  return new Promise((resolve) => {
    observable.subscribe(resolve)();
  });
}
function update(object, path, value) {
  object.update((o) => {
    set(o, path, value);
    return o;
  });
}
function cloneDeep(object) {
  return JSON.parse(JSON.stringify(object));
}
function isNullish(value) {
  return value === void 0 || value === null;
}
function isEmpty(object) {
  return isNullish(object) || Object.keys(object).length <= 0;
}
function getValues(object) {
  let results = [];
  for (const [, value] of Object.entries(object)) {
    const values = typeof value === "object" ? getValues(value) : [value];
    results = [...results, ...values];
  }
  return results;
}
function getErrorsFromSchema(initialValues, schema, errors = {}) {
  for (const key2 in schema) {
    switch (true) {
      case (schema[key2].type === "object" && !isEmpty(schema[key2].fields)): {
        errors[key2] = getErrorsFromSchema(
          initialValues[key2],
          schema[key2].fields,
          { ...errors[key2] }
        );
        break;
      }
      case schema[key2].type === "array": {
        const values = initialValues && initialValues[key2] ? initialValues[key2] : [];
        errors[key2] = values.map((value) => {
          const innerError = getErrorsFromSchema(
            value,
            schema[key2].innerType.fields,
            { ...errors[key2] }
          );
          return Object.keys(innerError).length > 0 ? innerError : "";
        });
        break;
      }
      default: {
        errors[key2] = "";
      }
    }
  }
  return errors;
}
var deepEqual = dequal;
function assignDeep(object, value) {
  if (Array.isArray(object)) {
    return object.map((o) => assignDeep(o, value));
  }
  const copy = {};
  for (const key2 in object) {
    copy[key2] = typeof object[key2] === "object" && !isNullish(object[key2]) ? assignDeep(object[key2], value) : value;
  }
  return copy;
}
function set(object, path, value) {
  if (new Object(object) !== object)
    return object;
  if (!Array.isArray(path)) {
    path = path.toString().match(/[^.[\]]+/g) || [];
  }
  const result = path.slice(0, -1).reduce(
    (accumulator, key2, index) => new Object(accumulator[key2]) === accumulator[key2] ? accumulator[key2] : accumulator[key2] = Math.trunc(Math.abs(path[index + 1])) === +path[index + 1] ? [] : {},
    object
  );
  result[path[path.length - 1]] = value;
  return object;
}
var util = {
  assignDeep,
  cloneDeep,
  deepEqual,
  getErrorsFromSchema,
  getValues,
  isEmpty,
  isNullish,
  set,
  subscribeOnce,
  update
};

// node_modules/svelte-forms-lib/lib/create-form.js
var NO_ERROR = "";
var IS_TOUCHED = true;
function isCheckbox(element2) {
  return element2.getAttribute && element2.getAttribute("type") === "checkbox";
}
function isFileInput(element2) {
  return element2.getAttribute && element2.getAttribute("type") === "file";
}
function resolveValue(element2) {
  if (isFileInput(element2)) {
    return element2.files;
  } else if (isCheckbox(element2)) {
    return element2.checked;
  } else {
    return element2.value;
  }
}
var createForm = (config) => {
  let initialValues = config.initialValues || {};
  const validationSchema = config.validationSchema;
  const validateFunction = config.validate;
  const onSubmit = config.onSubmit;
  const getInitial = {
    values: () => util.cloneDeep(initialValues),
    errors: () => validationSchema ? util.getErrorsFromSchema(initialValues, validationSchema.fields) : util.assignDeep(initialValues, NO_ERROR),
    touched: () => util.assignDeep(initialValues, !IS_TOUCHED)
  };
  const form = writable(getInitial.values());
  const errors = writable(getInitial.errors());
  const touched = writable(getInitial.touched());
  const isSubmitting = writable(false);
  const isValidating = writable(false);
  const isValid = derived(errors, ($errors) => {
    const noErrors = util.getValues($errors).every((field) => field === NO_ERROR);
    return noErrors;
  });
  const modified = derived(form, ($form) => {
    const object = util.assignDeep($form, false);
    for (let key2 in $form) {
      object[key2] = !util.deepEqual($form[key2], initialValues[key2]);
    }
    return object;
  });
  const isModified = derived(modified, ($modified) => {
    return util.getValues($modified).includes(true);
  });
  function validateField(field) {
    return util.subscribeOnce(form).then((values) => validateFieldValue(field, values[field]));
  }
  function validateFieldValue(field, value) {
    updateTouched(field, true);
    if (validationSchema) {
      isValidating.set(true);
      return validationSchema.validateAt(field, get_store_value(form)).then(() => util.update(errors, field, "")).catch((error) => util.update(errors, field, error.message)).finally(() => {
        isValidating.set(false);
      });
    }
    if (validateFunction) {
      isValidating.set(true);
      return Promise.resolve().then(() => validateFunction({ [field]: value })).then(
        (errs) => util.update(errors, field, !util.isNullish(errs) ? errs[field] : "")
      ).finally(() => {
        isValidating.set(false);
      });
    }
    return Promise.resolve();
  }
  function updateValidateField(field, value) {
    updateField(field, value);
    return validateFieldValue(field, value);
  }
  function handleChange(event) {
    const element2 = event.target;
    const field = element2.name || element2.id;
    const value = resolveValue(element2);
    return updateValidateField(field, value);
  }
  function handleSubmit(event) {
    if (event && event.preventDefault) {
      event.preventDefault();
    }
    isSubmitting.set(true);
    return util.subscribeOnce(form).then((values) => {
      if (typeof validateFunction === "function") {
        isValidating.set(true);
        return Promise.resolve().then(() => validateFunction(values)).then((error) => {
          if (util.isNullish(error) || util.getValues(error).length === 0) {
            return clearErrorsAndSubmit(values);
          } else {
            errors.set(error);
            isSubmitting.set(false);
          }
        }).finally(() => isValidating.set(false));
      }
      if (validationSchema) {
        isValidating.set(true);
        return validationSchema.validate(values, { abortEarly: false }).then(() => clearErrorsAndSubmit(values)).catch((yupErrors) => {
          if (yupErrors && yupErrors.inner) {
            const updatedErrors = getInitial.errors();
            yupErrors.inner.map(
              (error) => util.set(updatedErrors, error.path, error.message)
            );
            errors.set(updatedErrors);
          }
          isSubmitting.set(false);
        }).finally(() => isValidating.set(false));
      }
      return clearErrorsAndSubmit(values);
    });
  }
  function handleReset() {
    form.set(getInitial.values());
    errors.set(getInitial.errors());
    touched.set(getInitial.touched());
  }
  function clearErrorsAndSubmit(values) {
    return Promise.resolve().then(() => errors.set(getInitial.errors())).then(() => onSubmit(values, form, errors)).finally(() => isSubmitting.set(false));
  }
  function updateField(field, value) {
    util.update(form, field, value);
  }
  function updateTouched(field, value) {
    util.update(touched, field, value);
  }
  function updateInitialValues(newValues) {
    initialValues = newValues;
    handleReset();
  }
  return {
    form,
    errors,
    touched,
    modified,
    isValid,
    isSubmitting,
    isValidating,
    isModified,
    handleChange,
    handleSubmit,
    handleReset,
    updateField,
    updateValidateField,
    updateTouched,
    validateField,
    updateInitialValues,
    state: derived(
      [
        form,
        errors,
        touched,
        modified,
        isValid,
        isValidating,
        isSubmitting,
        isModified
      ],
      ([
        $form,
        $errors,
        $touched,
        $modified,
        $isValid,
        $isValidating,
        $isSubmitting,
        $isModified
      ]) => ({
        form: $form,
        errors: $errors,
        touched: $touched,
        modified: $modified,
        isValid: $isValid,
        isSubmitting: $isSubmitting,
        isValidating: $isValidating,
        isModified: $isModified
      })
    )
  };
};

// node_modules/svelte-forms-lib/lib/components/Form.svelte
var { Error: Error_1 } = globals;
var file = "node_modules/svelte-forms-lib/lib/components/Form.svelte";
var get_default_slot_changes = (dirty) => ({});
var get_default_slot_context = (ctx) => ({
  form: (
    /*form*/
    ctx[0]
  ),
  errors: (
    /*errors*/
    ctx[1]
  ),
  touched: (
    /*touched*/
    ctx[2]
  ),
  state: (
    /*state*/
    ctx[3]
  ),
  handleChange: (
    /*handleChange*/
    ctx[4]
  ),
  handleSubmit: (
    /*handleSubmit*/
    ctx[5]
  ),
  updateField: (
    /*updateField*/
    ctx[6]
  ),
  updateInitialValues: (
    /*updateInitialValues*/
    ctx[7]
  ),
  updateTouched: (
    /*updateTouched*/
    ctx[8]
  ),
  updateValidateField: (
    /*updateValidateField*/
    ctx[9]
  ),
  validateField: (
    /*validateField*/
    ctx[10]
  )
});
function create_fragment(ctx) {
  let form_1;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_default_slot_context
  );
  let form_1_levels = [
    /*$$restProps*/
    ctx[11]
  ];
  let form_data = {};
  for (let i = 0; i < form_1_levels.length; i += 1) {
    form_data = assign(form_data, form_1_levels[i]);
  }
  const block = {
    c: function create() {
      form_1 = element("form");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      form_1 = claim_element(nodes, "FORM", {});
      var form_1_nodes = children(form_1);
      if (default_slot)
        default_slot.l(form_1_nodes);
      form_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(form_1, form_data);
      add_location(form_1, file, 49, 0, 921);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, form_1, anchor);
      if (default_slot) {
        default_slot.m(form_1, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          form_1,
          "submit",
          /*handleSubmit*/
          ctx[5],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update2(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        131072)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
      set_attributes(form_1, form_data = get_spread_update(form_1_levels, [dirty & /*$$restProps*/
      2048 && /*$$restProps*/
      ctx2[11]]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(form_1);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  const omit_props_names = ["initialValues", "validate", "validationSchema", "onSubmit", "context"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Form", slots, ["default"]);
  let { initialValues = {} } = $$props;
  let { validate = null } = $$props;
  let { validationSchema = null } = $$props;
  let { onSubmit = () => {
    throw new Error("onSubmit is a required property in <Form /> when using the fallback context");
  } } = $$props;
  let { context = createForm({
    initialValues,
    onSubmit,
    validate,
    validationSchema
  }) } = $$props;
  const { form, errors, touched, state, handleChange, handleSubmit, updateField, updateInitialValues, updateTouched, updateValidateField, validateField } = context;
  setContext(key, {
    form,
    errors,
    touched,
    state,
    handleChange,
    handleSubmit,
    updateField,
    updateInitialValues,
    updateTouched,
    updateValidateField,
    validateField
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("initialValues" in $$new_props)
      $$invalidate(12, initialValues = $$new_props.initialValues);
    if ("validate" in $$new_props)
      $$invalidate(13, validate = $$new_props.validate);
    if ("validationSchema" in $$new_props)
      $$invalidate(14, validationSchema = $$new_props.validationSchema);
    if ("onSubmit" in $$new_props)
      $$invalidate(15, onSubmit = $$new_props.onSubmit);
    if ("context" in $$new_props)
      $$invalidate(16, context = $$new_props.context);
    if ("$$scope" in $$new_props)
      $$invalidate(17, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    setContext,
    createForm,
    key,
    initialValues,
    validate,
    validationSchema,
    onSubmit,
    context,
    form,
    errors,
    touched,
    state,
    handleChange,
    handleSubmit,
    updateField,
    updateInitialValues,
    updateTouched,
    updateValidateField,
    validateField
  });
  $$self.$inject_state = ($$new_props) => {
    if ("initialValues" in $$props)
      $$invalidate(12, initialValues = $$new_props.initialValues);
    if ("validate" in $$props)
      $$invalidate(13, validate = $$new_props.validate);
    if ("validationSchema" in $$props)
      $$invalidate(14, validationSchema = $$new_props.validationSchema);
    if ("onSubmit" in $$props)
      $$invalidate(15, onSubmit = $$new_props.onSubmit);
    if ("context" in $$props)
      $$invalidate(16, context = $$new_props.context);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    form,
    errors,
    touched,
    state,
    handleChange,
    handleSubmit,
    updateField,
    updateInitialValues,
    updateTouched,
    updateValidateField,
    validateField,
    $$restProps,
    initialValues,
    validate,
    validationSchema,
    onSubmit,
    context,
    $$scope,
    slots
  ];
}
var Form = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      initialValues: 12,
      validate: 13,
      validationSchema: 14,
      onSubmit: 15,
      context: 16
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Form",
      options,
      id: create_fragment.name
    });
  }
  get initialValues() {
    throw new Error_1("<Form>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set initialValues(value) {
    throw new Error_1("<Form>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get validate() {
    throw new Error_1("<Form>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set validate(value) {
    throw new Error_1("<Form>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get validationSchema() {
    throw new Error_1("<Form>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set validationSchema(value) {
    throw new Error_1("<Form>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onSubmit() {
    throw new Error_1("<Form>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onSubmit(value) {
    throw new Error_1("<Form>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get context() {
    throw new Error_1("<Form>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set context(value) {
    throw new Error_1("<Form>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Form_default = Form;

// node_modules/svelte-forms-lib/lib/components/Textarea.svelte
var file2 = "node_modules/svelte-forms-lib/lib/components/Textarea.svelte";
function create_fragment2(ctx) {
  let textarea;
  let textarea_value_value;
  let mounted;
  let dispose;
  let textarea_levels = [
    { name: (
      /*name*/
      ctx[0]
    ) },
    /*$$props*/
    ctx[4],
    {
      value: textarea_value_value = /*$form*/
      ctx[1][
        /*name*/
        ctx[0]
      ]
    }
  ];
  let textarea_data = {};
  for (let i = 0; i < textarea_levels.length; i += 1) {
    textarea_data = assign(textarea_data, textarea_levels[i]);
  }
  const block = {
    c: function create() {
      textarea = element("textarea");
      this.h();
    },
    l: function claim(nodes) {
      textarea = claim_element(nodes, "TEXTAREA", { name: true });
      children(textarea).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(textarea, textarea_data);
      add_location(textarea, file2, 10, 0, 180);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, textarea, anchor);
      if (textarea.autofocus)
        textarea.focus();
      if (!mounted) {
        dispose = [
          listen_dev(
            textarea,
            "change",
            /*handleChange*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            textarea,
            "blur",
            /*handleChange*/
            ctx[3],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update2(ctx2, [dirty]) {
      set_attributes(textarea, textarea_data = get_spread_update(textarea_levels, [
        dirty & /*name*/
        1 && { name: (
          /*name*/
          ctx2[0]
        ) },
        dirty & /*$$props*/
        16 && /*$$props*/
        ctx2[4],
        dirty & /*$form, name*/
        3 && textarea_value_value !== (textarea_value_value = /*$form*/
        ctx2[1][
          /*name*/
          ctx2[0]
        ]) && { value: textarea_value_value }
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(textarea);
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let $form;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Textarea", slots, []);
  let { name } = $$props;
  const { form, handleChange } = getContext(key);
  validate_store(form, "form");
  component_subscribe($$self, form, (value) => $$invalidate(1, $form = value));
  $$self.$$.on_mount.push(function() {
    if (name === void 0 && !("name" in $$props || $$self.$$.bound[$$self.$$.props["name"]])) {
      console.warn("<Textarea> was created without expected prop 'name'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("name" in $$new_props)
      $$invalidate(0, name = $$new_props.name);
  };
  $$self.$capture_state = () => ({
    getContext,
    key,
    name,
    form,
    handleChange,
    $form
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(4, $$props = assign(assign({}, $$props), $$new_props));
    if ("name" in $$props)
      $$invalidate(0, name = $$new_props.name);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [name, $form, form, handleChange, $$props];
}
var Textarea = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Textarea",
      options,
      id: create_fragment2.name
    });
  }
  get name() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Textarea_default = Textarea;

// node_modules/svelte-forms-lib/lib/components/Field.svelte
var file3 = "node_modules/svelte-forms-lib/lib/components/Field.svelte";
function create_fragment3(ctx) {
  let input;
  let input_value_value;
  let mounted;
  let dispose;
  let input_levels = [
    { name: (
      /*name*/
      ctx[0]
    ) },
    { type: (
      /*type*/
      ctx[1]
    ) },
    {
      value: input_value_value = /*$form*/
      ctx[2][
        /*name*/
        ctx[0]
      ]
    },
    /*$$props*/
    ctx[5]
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", { name: true, type: true });
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file3, 10, 0, 183);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if ("value" in input_data) {
        input.value = input_data.value;
      }
      if (input.autofocus)
        input.focus();
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*handleChange*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "blur",
            /*handleChange*/
            ctx[4],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update2(ctx2, [dirty]) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty & /*name*/
        1 && { name: (
          /*name*/
          ctx2[0]
        ) },
        dirty & /*type*/
        2 && { type: (
          /*type*/
          ctx2[1]
        ) },
        dirty & /*$form, name*/
        5 && input_value_value !== (input_value_value = /*$form*/
        ctx2[2][
          /*name*/
          ctx2[0]
        ]) && input.value !== input_value_value && { value: input_value_value },
        dirty & /*$$props*/
        32 && /*$$props*/
        ctx2[5]
      ]));
      if ("value" in input_data) {
        input.value = input_data.value;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let $form;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Field", slots, []);
  let { name } = $$props;
  let { type = "text" } = $$props;
  const { form, handleChange } = getContext(key);
  validate_store(form, "form");
  component_subscribe($$self, form, (value) => $$invalidate(2, $form = value));
  $$self.$$.on_mount.push(function() {
    if (name === void 0 && !("name" in $$props || $$self.$$.bound[$$self.$$.props["name"]])) {
      console.warn("<Field> was created without expected prop 'name'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("name" in $$new_props)
      $$invalidate(0, name = $$new_props.name);
    if ("type" in $$new_props)
      $$invalidate(1, type = $$new_props.type);
  };
  $$self.$capture_state = () => ({
    getContext,
    key,
    name,
    type,
    form,
    handleChange,
    $form
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("name" in $$props)
      $$invalidate(0, name = $$new_props.name);
    if ("type" in $$props)
      $$invalidate(1, type = $$new_props.type);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [name, type, $form, form, handleChange, $$props];
}
var Field = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { name: 0, type: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Field",
      options,
      id: create_fragment3.name
    });
  }
  get name() {
    throw new Error("<Field>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Field>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<Field>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Field>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Field_default = Field;

// node_modules/svelte-forms-lib/lib/components/Select.svelte
var file4 = "node_modules/svelte-forms-lib/lib/components/Select.svelte";
function create_fragment4(ctx) {
  let select;
  let select_value_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let select_levels = [
    { name: (
      /*name*/
      ctx[0]
    ) },
    {
      value: select_value_value = /*$form*/
      ctx[1][
        /*name*/
        ctx[0]
      ]
    },
    /*$$props*/
    ctx[4]
  ];
  let select_data = {};
  for (let i = 0; i < select_levels.length; i += 1) {
    select_data = assign(select_data, select_levels[i]);
  }
  const block = {
    c: function create() {
      select = element("select");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      select = claim_element(nodes, "SELECT", { name: true });
      var select_nodes = children(select);
      if (default_slot)
        default_slot.l(select_nodes);
      select_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(select, select_data);
      add_location(select, file4, 9, 0, 155);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, select, anchor);
      if (default_slot) {
        default_slot.m(select, null);
      }
      "value" in select_data && (select_data.multiple ? select_options : select_option)(select, select_data.value);
      if (select.autofocus)
        select.focus();
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            select,
            "change",
            /*handleChange*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            select,
            "blur",
            /*handleChange*/
            ctx[3],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update2(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(select, select_data = get_spread_update(select_levels, [
        (!current || dirty & /*name*/
        1) && { name: (
          /*name*/
          ctx2[0]
        ) },
        (!current || dirty & /*$form, name*/
        3 && select_value_value !== (select_value_value = /*$form*/
        ctx2[1][
          /*name*/
          ctx2[0]
        ])) && { value: select_value_value },
        dirty & /*$$props*/
        16 && /*$$props*/
        ctx2[4]
      ]));
      if (dirty & /*name, $form, $$props*/
      19 && "value" in select_data)
        (select_data.multiple ? select_options : select_option)(select, select_data.value);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(select);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let $form;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Select", slots, ["default"]);
  let { name } = $$props;
  const { form, handleChange } = getContext(key);
  validate_store(form, "form");
  component_subscribe($$self, form, (value) => $$invalidate(1, $form = value));
  $$self.$$.on_mount.push(function() {
    if (name === void 0 && !("name" in $$props || $$self.$$.bound[$$self.$$.props["name"]])) {
      console.warn("<Select> was created without expected prop 'name'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("name" in $$new_props)
      $$invalidate(0, name = $$new_props.name);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    key,
    name,
    form,
    handleChange,
    $form
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(4, $$props = assign(assign({}, $$props), $$new_props));
    if ("name" in $$props)
      $$invalidate(0, name = $$new_props.name);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [name, $form, form, handleChange, $$props, $$scope, slots];
}
var Select = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Select",
      options,
      id: create_fragment4.name
    });
  }
  get name() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Select_default = Select;

// node_modules/svelte-forms-lib/lib/components/ErrorMessage.svelte
var file5 = "node_modules/svelte-forms-lib/lib/components/ErrorMessage.svelte";
function create_if_block(ctx) {
  let small;
  let t_value = (
    /*$errors*/
    ctx[1][
      /*name*/
      ctx[0]
    ] + ""
  );
  let t;
  let small_levels = [
    /*$$props*/
    ctx[3]
  ];
  let small_data = {};
  for (let i = 0; i < small_levels.length; i += 1) {
    small_data = assign(small_data, small_levels[i]);
  }
  const block = {
    c: function create() {
      small = element("small");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      small = claim_element(nodes, "SMALL", {});
      var small_nodes = children(small);
      t = claim_text(small_nodes, t_value);
      small_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(small, small_data);
      add_location(small, file5, 10, 2, 165);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, small, anchor);
      append_hydration_dev(small, t);
    },
    p: function update2(ctx2, dirty) {
      if (dirty & /*$errors, name*/
      3 && t_value !== (t_value = /*$errors*/
      ctx2[1][
        /*name*/
        ctx2[0]
      ] + ""))
        set_data_maybe_contenteditable_dev(t, t_value, small_data["contenteditable"]);
      set_attributes(small, small_data = get_spread_update(small_levels, [dirty & /*$$props*/
      8 && /*$$props*/
      ctx2[3]]));
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(small);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(10:0) {#if $errors[name]}",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let if_block_anchor;
  let if_block = (
    /*$errors*/
    ctx[1][
      /*name*/
      ctx[0]
    ] && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update2(ctx2, [dirty]) {
      if (
        /*$errors*/
        ctx2[1][
          /*name*/
          ctx2[0]
        ]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let $errors;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ErrorMessage", slots, []);
  let { name } = $$props;
  const { errors } = getContext(key);
  validate_store(errors, "errors");
  component_subscribe($$self, errors, (value) => $$invalidate(1, $errors = value));
  $$self.$$.on_mount.push(function() {
    if (name === void 0 && !("name" in $$props || $$self.$$.bound[$$self.$$.props["name"]])) {
      console.warn("<ErrorMessage> was created without expected prop 'name'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("name" in $$new_props)
      $$invalidate(0, name = $$new_props.name);
  };
  $$self.$capture_state = () => ({ getContext, key, name, errors, $errors });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(3, $$props = assign(assign({}, $$props), $$new_props));
    if ("name" in $$props)
      $$invalidate(0, name = $$new_props.name);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [name, $errors, errors, $$props];
}
var ErrorMessage = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ErrorMessage",
      options,
      id: create_fragment5.name
    });
  }
  get name() {
    throw new Error("<ErrorMessage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<ErrorMessage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ErrorMessage_default = ErrorMessage;
export {
  ErrorMessage_default as ErrorMessage,
  Field_default as Field,
  Form_default as Form,
  Select_default as Select,
  Textarea_default as Textarea,
  createForm,
  key
};
//# sourceMappingURL=svelte-forms-lib.js.map
