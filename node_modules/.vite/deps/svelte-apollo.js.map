{
  "version": 3,
  "sources": ["../../svelte-apollo/src/context.ts", "../../svelte-apollo/src/mutation.ts", "../../svelte-apollo/src/observable.ts", "../../svelte-apollo/src/restore.ts", "../../svelte-apollo/src/query.ts", "../../svelte-apollo/src/subscribe.ts"],
  "sourcesContent": ["import type { ApolloClient } from \"@apollo/client/core\";\nimport { getContext, setContext } from \"svelte\";\n\nconst CLIENT = typeof Symbol !== \"undefined\" ? Symbol(\"client\") : \"@@client\";\n\nexport function getClient<TCache = any>(): ApolloClient<TCache> {\n\tconst client = getContext(CLIENT);\n\n\tif (!client) {\n\t\tthrow new Error(\n\t\t\t\"ApolloClient has not been set yet, use setClient(new ApolloClient({ ... })) to define it\"\n\t\t);\n\t}\n\n\treturn client as ApolloClient<TCache>;\n}\n\nexport function setClient<TCache = any>(client: ApolloClient<TCache>): void {\n\tsetContext(CLIENT, client);\n}\n", "import type { FetchResult, MutationOptions } from \"@apollo/client/core\";\nimport type { DocumentNode } from \"graphql\";\nimport { getClient } from \"./context\";\n\nexport type MutateOptions<T = unknown, TVariables = unknown> = Omit<\n\tMutationOptions<T, TVariables>,\n\t\"mutation\"\n>;\n\nexport type Mutate<T = unknown, TVariables = unknown> = (\n\toptions: MutateOptions<T, TVariables>\n) => Promise<FetchResult<T>>;\n\nexport function mutation<T = unknown, TVariables = unknown>(\n\tmutation: DocumentNode,\n\tinitialOptions: MutateOptions<T, TVariables> = {}\n): Mutate<T, TVariables> {\n\tconst client = getClient();\n\n\treturn (options: MutateOptions<T, TVariables>) =>\n\t\tclient.mutate({ mutation, ...initialOptions, ...options });\n}\n", "import { ApolloError } from \"@apollo/client/core\";\nimport type {\n\tFetchResult,\n\tObservable,\n\tObservableQuery,\n} from \"@apollo/client/core\";\nimport { readable } from \"svelte/store\";\nimport type { Readable } from \"svelte/store\";\n\n// Match Apollo's hook approach, by returning a result with three states:\n// loading, error, or data (where data could be null / undefined)\n\nexport interface LoadingState {\n\tloading: true;\n\tdata?: undefined;\n\terror?: undefined;\n}\nexport interface ErrorState {\n\tloading: false;\n\tdata?: undefined;\n\terror: ApolloError | Error;\n}\nexport interface DataState<TData = unknown> {\n\tloading: false;\n\tdata: TData | null | undefined;\n\terror?: undefined;\n}\n\nexport type Result<TData = unknown> =\n\t| LoadingState\n\t| ErrorState\n\t| DataState<TData>;\n\n// Some methods, e.g. subscription, use Observable<FetchResult>,\n// convert this more raw value to a readable\n\nexport type ReadableResult<TData = unknown> = Readable<Result<TData>>;\n\nexport function observableToReadable<TData = unknown>(\n\tobservable: Observable<FetchResult<TData>>,\n\tinitialValue: Result<TData> = {\n\t\tloading: true,\n\t\tdata: undefined,\n\t\terror: undefined,\n\t}\n): ReadableResult<TData> {\n\tconst store = readable<Result<TData>>(initialValue, (set) => {\n\t\tconst skipDuplicate = initialValue?.data !== undefined;\n\t\tlet skipped = false;\n\n\t\tconst subscription = observable.subscribe(\n\t\t\t(result: FetchResult<TData>) => {\n\t\t\t\tif (skipDuplicate && !skipped) {\n\t\t\t\t\tskipped = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (result.errors) {\n\t\t\t\t\tconst error = new ApolloError({ graphQLErrors: result.errors });\n\t\t\t\t\tset({ loading: false, data: undefined, error });\n\t\t\t\t} else {\n\t\t\t\t\tset({ loading: false, data: result.data, error: undefined });\n\t\t\t\t}\n\t\t\t},\n\t\t\t(error: any) =>\n\t\t\t\tset({\n\t\t\t\t\tloading: false,\n\t\t\t\t\tdata: undefined,\n\t\t\t\t\terror: error && \"message\" in error ? error : new Error(error),\n\t\t\t\t})\n\t\t);\n\n\t\treturn () => subscription.unsubscribe();\n\t});\n\n\treturn store;\n}\n\n// For live queries, ObservableQuery is used, adding methods like refetch\n// extend readable with these methods\n\nexport interface ObservableQueryExtensions<TData = unknown> {\n\tfetchMore: ObservableQuery<TData>[\"fetchMore\"];\n\tgetCurrentResult: ObservableQuery<TData>[\"getCurrentResult\"];\n\tgetLastError: ObservableQuery<TData>[\"getLastError\"];\n\tgetLastResult: ObservableQuery<TData>[\"getLastResult\"];\n\tisDifferentFromLastResult: ObservableQuery<TData>[\"isDifferentFromLastResult\"];\n\trefetch: ObservableQuery<TData>[\"refetch\"];\n\tresetLastResults: ObservableQuery<TData>[\"resetLastResults\"];\n\tresetQueryStoreErrors: ObservableQuery<TData>[\"resetQueryStoreErrors\"];\n\tresult: ObservableQuery<TData>[\"result\"];\n\tsetOptions: ObservableQuery<TData>[\"setOptions\"];\n\tsetVariables: ObservableQuery<TData>[\"setVariables\"];\n\tstartPolling: ObservableQuery<TData>[\"startPolling\"];\n\tstopPolling: ObservableQuery<TData>[\"stopPolling\"];\n\tsubscribeToMore: ObservableQuery<TData>[\"subscribeToMore\"];\n\tupdateQuery: ObservableQuery<TData>[\"updateQuery\"];\n}\n\nexport const extensions: Array<keyof ObservableQueryExtensions> = [\n\t\"fetchMore\",\n\t\"getCurrentResult\",\n\t\"getLastError\",\n\t\"getLastResult\",\n\t\"isDifferentFromLastResult\",\n\t\"refetch\",\n\t\"resetLastResults\",\n\t\"resetQueryStoreErrors\",\n\t\"result\",\n\t\"setOptions\",\n\t\"setVariables\",\n\t\"startPolling\",\n\t\"stopPolling\",\n\t\"subscribeToMore\",\n\t\"updateQuery\",\n];\n\nexport type ReadableQuery<TData> = ReadableResult<TData> &\n\tObservableQueryExtensions<TData>;\n\nexport function observableQueryToReadable<\n\tTData = unknown,\n\tTVariables = unknown\n>(\n\tquery: ObservableQuery<TData, TVariables>,\n\tinitialValue?: Result<TData>\n): ReadableQuery<TData> {\n\tconst store = observableToReadable(\n\t\tquery,\n\t\tinitialValue\n\t) as ReadableQuery<TData>;\n\n\tfor (const extension of extensions) {\n\t\tstore[extension] = query[extension].bind(query) as any;\n\t}\n\n\treturn store;\n}\n", "import type {\n\tApolloClient,\n\tDataProxy,\n\tOperationVariables,\n} from \"@apollo/client/core\";\nimport type { DocumentNode } from \"graphql\";\nimport { onMount } from \"svelte\";\nimport { getClient } from \"./context\";\n\nexport type Restoring<TCache> =\n\t| WeakSet<ApolloClient<TCache>>\n\t| Set<ApolloClient<TCache>>;\n\nexport const restoring: Restoring<unknown> =\n\ttypeof WeakSet !== \"undefined\" ? new WeakSet() : new Set();\n\nexport function restore<TData = unknown, TVariables = OperationVariables>(\n\tquery: DocumentNode,\n\toptions: Omit<DataProxy.WriteQueryOptions<TData, TVariables>, \"query\">\n): void {\n\tconst client = getClient();\n\n\trestoring.add(client);\n\tafterHydrate(() => restoring.delete(client));\n\n\tclient.writeQuery({ query, ...options });\n}\n\nfunction afterHydrate(callback: () => void): void {\n\t// Attempt to wait for onMount (hydration of current component is complete),\n\t// but if that fails (e.g. outside of component initialization)\n\t// wait for next event loop for hydrate to complete\n\n\ttry {\n\t\tonMount(callback);\n\t} catch (_error) {\n\t\tsetTimeout(callback, 1);\n\t}\n}\n", "import type { WatchQueryOptions } from \"@apollo/client/core\";\nimport type { DocumentNode } from \"graphql\";\nimport { getClient } from \"./context\";\nimport { DataState, observableQueryToReadable } from \"./observable\";\nimport type { ReadableQuery } from \"./observable\";\nimport { restoring } from \"./restore\";\n\nexport function query<TData = unknown, TVariables = unknown>(\n\tquery: DocumentNode,\n\toptions: Omit<WatchQueryOptions<TVariables, TData>, \"query\"> = {}\n): ReadableQuery<TData> {\n\tconst client = getClient();\n\tconst queryOptions = { ...options, query } as WatchQueryOptions<\n\t\tTVariables,\n\t\tTData\n\t>;\n\n\t// If client is restoring (e.g. from SSR), attempt synchronous readQuery first\n\tlet initialValue: TData | undefined;\n\tif (restoring.has(client)) {\n\t\ttry {\n\t\t\t// undefined = skip initial value (not in cache)\n\t\t\tinitialValue = client.readQuery(queryOptions) || undefined;\n\t\t} catch (err) {\n\t\t\t// Ignore preload errors\n\t\t}\n\t}\n\n\tconst observable = client.watchQuery<TData, TVariables>(queryOptions);\n\tconst store = observableQueryToReadable(\n\t\tobservable,\n\t\tinitialValue !== undefined\n\t\t\t? ({\n\t\t\t\t\tdata: initialValue,\n\t\t\t  } as DataState<TData>)\n\t\t\t: undefined\n\t);\n\n\treturn store;\n}\n", "import type { SubscriptionOptions } from \"@apollo/client/core\";\nimport type { DocumentNode } from \"graphql\";\nimport { getClient } from \"./context\";\nimport { observableToReadable } from \"./observable\";\nimport type { ReadableResult } from \"./observable\";\n\nexport function subscribe<TData = unknown, TVariables = unknown>(\n\tquery: DocumentNode,\n\toptions: Omit<SubscriptionOptions<TVariables>, \"query\"> = {}\n): ReadableResult<TData> {\n\tconst client = getClient();\n\tconst observable = client.subscribe<TData, TVariables>({ query, ...options });\n\n\treturn observableToReadable<TData>(observable);\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;AAGA,IAAM,SAAS,OAAO,WAAW,cAAc,OAAO,QAAQ,IAAI;SAElD,YAAS;AACxB,QAAM,SAAS,WAAW,MAAM;AAEhC,MAAI,CAAC,QAAQ;AACZ,UAAM,IAAI,MACT,0FAA0F;;AAI5F,SAAO;AACR;SAEgB,UAAwB,QAA4B;AACnE,aAAW,QAAQ,MAAM;AAC1B;SCNgB,SACfA,WACA,iBAA+C,CAAA,GAAE;AAEjD,QAAM,SAAS,UAAS;AAExB,SAAO,CAAC,YACP,OAAO,OAAO,EAAE,UAAAA,WAAU,GAAG,gBAAgB,GAAG,QAAO,CAAE;AAC3D;SCiBgB,qBACf,YACA,eAA8B;EAC7B,SAAS;EACT,MAAM;EACN,OAAO;GACP;AAED,QAAM,QAAQ,SAAwB,cAAc,CAAC,QAAG;AACvD,UAAM,iBAAgB,6CAAc,UAAS;AAC7C,QAAI,UAAU;AAEd,UAAM,eAAe,WAAW,UAC/B,CAAC,WAA0B;AAC1B,UAAI,iBAAiB,CAAC,SAAS;AAC9B,kBAAU;AACV;;AAGD,UAAI,OAAO,QAAQ;AAClB,cAAM,QAAQ,IAAI,YAAY,EAAE,eAAe,OAAO,OAAM,CAAE;AAC9D,YAAI,EAAE,SAAS,OAAO,MAAM,QAAW,MAAK,CAAE;aACxC;AACN,YAAI,EAAE,SAAS,OAAO,MAAM,OAAO,MAAM,OAAO,OAAS,CAAE;;OAG7D,CAAC,UACA,IAAI;MACH,SAAS;MACT,MAAM;MACN,OAAO,SAAS,aAAa,QAAQ,QAAQ,IAAI,MAAM,KAAK;KAC5D,CAAC;AAGJ,WAAO,MAAM,aAAa,YAAW;GACrC;AAED,SAAO;AACR;AAuBO,IAAM,aAAqD;EACjE;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;SAMe,0BAIfC,QACA,cAA4B;AAE5B,QAAM,QAAQ,qBACbA,QACA,YAAY;AAGb,aAAW,aAAa,YAAY;AACnC,UAAM,SAAS,IAAIA,OAAM,SAAS,EAAE,KAAKA,MAAK;;AAG/C,SAAO;AACR;AC5HO,IAAM,YACZ,OAAO,YAAY,cAAc,oBAAI,QAAO,IAAK,oBAAI,IAAG;SAEzC,QACfA,QACA,SAAsE;AAEtE,QAAM,SAAS,UAAS;AAExB,YAAU,IAAI,MAAM;AACpB,eAAa,MAAM,UAAU,OAAO,MAAM,CAAC;AAE3C,SAAO,WAAW,EAAE,OAAAA,QAAO,GAAG,QAAO,CAAE;AACxC;AAEA,SAAS,aAAa,UAAoB;AAKzC,MAAI;AACH,YAAQ,QAAQ;WACR,QAAQ;AAChB,eAAW,UAAU,CAAC;;AAExB;SC/BgB,MACfA,QACA,UAA+D,CAAA,GAAE;AAEjE,QAAM,SAAS,UAAS;AACxB,QAAM,eAAe,EAAE,GAAG,SAAS,OAAAA,OAAK;AAMxC,MAAI;AACJ,MAAI,UAAU,IAAI,MAAM,GAAG;AAC1B,QAAI;AAEH,qBAAe,OAAO,UAAU,YAAY,KAAK;aACzC,KAAK;;;AAKf,QAAM,aAAa,OAAO,WAA8B,YAAY;AACpE,QAAM,QAAQ,0BACb,YACA,iBAAiB,SACb;IACD,MAAM;MAEN,MAAS;AAGb,SAAO;AACR;SCjCgB,UACfA,QACA,UAA0D,CAAA,GAAE;AAE5D,QAAM,SAAS,UAAS;AACxB,QAAM,aAAa,OAAO,UAA6B,EAAE,OAAAA,QAAO,GAAG,QAAO,CAAE;AAE5E,SAAO,qBAA4B,UAAU;AAC9C;",
  "names": ["mutation", "query"]
}
