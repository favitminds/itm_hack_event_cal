import { stry, Log, logCyan, logGreen, logRed, logYellow, sleep } from '@kitql/helper';

class InMemoryCache {
    constructor() {
        this.cacheIndexes = {};
        this.cacheData = {};
    }
    set(operationKey, data) {
        const v = stry(data.variables, 0);
        const fullKey = stry({ k: operationKey, v }, 0);
        // Indexes
        if (this.cacheIndexes[operationKey] !== undefined) {
            if (this.cacheData[fullKey] === undefined) {
                this.cacheIndexes[operationKey].push(v);
            }
        }
        else {
            this.cacheIndexes[operationKey] = [v];
        }
        // Data
        this.cacheData[fullKey] = data;
    }
    get(operationKey, variables = null) {
        // Data
        const v = stry(variables, 0);
        const fullKey = stry({ k: operationKey, v }, 0);
        return this.cacheData[fullKey];
    }
    remove(operationKey, variables = null, allOperationKey = true) {
        let nbDeleted = 0;
        if (this.cacheIndexes[operationKey] !== undefined) {
            if (allOperationKey) {
                const keys = this.cacheIndexes[operationKey];
                for (let i = 0; i < keys.length; i++) {
                    const v = keys[i];
                    const fullKey = stry({ k: operationKey, v }, 0);
                    delete this.cacheData[fullKey];
                    nbDeleted++;
                }
                delete this.cacheIndexes[operationKey];
            }
            else {
                const v = stry(variables, 0);
                const fullKey = stry({ k: operationKey, v }, 0);
                if (this.cacheData[fullKey] !== undefined) {
                    delete this.cacheData[fullKey];
                    this.cacheIndexes[operationKey] = this.cacheIndexes[operationKey].filter((c) => c !== v);
                    nbDeleted = 1;
                }
            }
        }
        return nbDeleted;
    }
}

class LocalStorageCache {
    set(operationKey, data) {
        const v = stry(data.variables, 0);
        const fullKey = stry({ k: operationKey, v }, 0);
        //INDEXES
        const rawIndexes = window.localStorage.getItem(operationKey);
        if (rawIndexes) {
            const indexes = JSON.parse(rawIndexes);
            if (!window.localStorage.getItem(fullKey)) {
                indexes.push(v);
                //only saves a valid array
                window.localStorage.setItem(operationKey, JSON.stringify(indexes));
            }
        }
        else {
            window.localStorage.setItem(operationKey, JSON.stringify([v]));
        }
        // Data
        window.localStorage.setItem(fullKey, stry(data, 0));
    }
    get(operationKey, variables = null) {
        //Data
        const v = stry(variables, 0);
        const fullKey = stry({ k: operationKey, v }, 0);
        const data = window.localStorage.getItem(fullKey);
        if (!data)
            return undefined;
        return JSON.parse(data);
    }
    remove(operationKey, variables = null, allOperationKey = true) {
        let nbDeleted = 0;
        const rawIndexes = window.localStorage.getItem(operationKey);
        if (rawIndexes) {
            const indexes = JSON.parse(rawIndexes);
            if (allOperationKey) {
                const keysToDelete = indexes.map((v) => stry({ k: operationKey, v }, 0));
                nbDeleted = keysToDelete.length;
                window.localStorage.removeItem(operationKey);
                keysToDelete.forEach((key) => window.localStorage.removeItem(key));
            }
            else {
                const v = stry(variables, 0);
                const fullKey = stry({ k: operationKey, v }, 0);
                window.localStorage.removeItem(fullKey);
                const newIndexes = indexes.filter((c) => c !== v);
                window.localStorage.setItem(operationKey, JSON.stringify(newIndexes));
                nbDeleted = 1;
            }
        }
        return nbDeleted;
    }
}

function printBlockString(n) {
  return '"""\n' + JSON.stringify(n).slice(1, -1) + '\n"""';
}

var r = JSON.stringify;

function print(r$1) {
  if (Array.isArray(r$1)) {
    return r$1.map(print);
  } else if (null == r$1 || "object" != typeof r$1) {
    return r$1 ? "" + r$1 : "";
  }
  switch (r$1.kind) {
   case "OperationDefinition":
    var t = join([ r$1.operation, print(r$1.name) + wrap("(", join(print(r$1.variableDefinitions), ", "), ")"), join(print(r$1.directives), " ") ], " ");
    return ("query" === t ? "" : t + " ") + print(r$1.selectionSet);

   case "VariableDefinition":
    return print(r$1.variable) + ": " + print(r$1.type) + wrap(" = ", print(r$1.defaultValue)) + wrap(" ", join(print(r$1.directives), " "));

   case "Field":
    return join([ wrap("", print(r$1.alias), ": ") + print(r$1.name) + wrap("(", join(print(r$1.arguments), ", "), ")"), join(print(r$1.directives), " "), print(r$1.selectionSet) ], " ");

   case "StringValue":
    return r$1.isBlockString ? printBlockString(r$1.value) : r(r$1.value);

   case "BooleanValue":
    return r$1.value ? "true" : "false";

   case "NullValue":
    return "null";

   case "IntValue":
   case "FloatValue":
   case "EnumValue":
   case "Name":
    return r$1.value;

   case "ListValue":
    return "[" + join(print(r$1.values), ", ") + "]";

   case "ObjectValue":
    return "{" + join(print(r$1.fields), ", ") + "}";

   case "ObjectField":
    return r$1.name.value + ": " + print(r$1.value);

   case "Variable":
    return "$" + r$1.name.value;

   case "Document":
    return join(print(r$1.definitions), "\n\n") + "\n";

   case "SelectionSet":
    return block(print(r$1.selections));

   case "Argument":
    return r$1.name.value + ": " + print(r$1.value);

   case "FragmentSpread":
    return "..." + print(r$1.name) + wrap(" ", join(print(r$1.directives), " "));

   case "InlineFragment":
    return join([ "...", wrap("on ", print(r$1.typeCondition)), join(print(r$1.directives), " "), print(r$1.selectionSet) ], " ");

   case "FragmentDefinition":
    return "fragment " + r$1.name.value + wrap("(", join(print(r$1.variableDefinitions), ", "), ")") + " on " + print(r$1.typeCondition) + " " + wrap("", join(print(r$1.directives), " "), " ") + print(r$1.selectionSet);

   case "Directive":
    return "@" + r$1.name.value + wrap("(", join(print(r$1.arguments), ", "), ")");

   case "NamedType":
    return r$1.name.value;

   case "ListType":
    return "[" + print(r$1.type) + "]";

   case "NonNullType":
    return print(r$1.type) + "!";

   default:
    return "";
  }
}

var join = function(e, n) {
  return e && e.filter((function(e) {
    return e;
  })).join(n || "") || "";
};

var block = function(e) {
  return wrap("{\n  ", join(e, "\n").replace(/\n/g, "\n  "), "\n}");
};

var wrap = function(e, n, r) {
  return n ? e + n + (r || "") : "";
};

var RequestStatus;
(function (RequestStatus) {
    RequestStatus["NEVER"] = "NEVER";
    RequestStatus["LOADING"] = "LOADING";
    RequestStatus["DONE"] = "DONE";
})(RequestStatus || (RequestStatus = {}));
var RequestFrom;
(function (RequestFrom) {
    RequestFrom["NODATA"] = "NODATA";
    RequestFrom["NETWORK"] = "NETWORK";
    RequestFrom["SSR"] = "SSR";
    RequestFrom["CACHE"] = "CACHE";
})(RequestFrom || (RequestFrom = {}));
var ResponseResultType;
(function (ResponseResultType) {
    ResponseResultType["Query"] = "Query";
    ResponseResultType["Mutation"] = "Mutation";
})(ResponseResultType || (ResponseResultType = {}));
const defaultStoreValue = {
    status: RequestStatus.NEVER,
    isFetching: false,
    date: new Date().getTime(),
    operationName: '???',
    operationType: ResponseResultType.Query,
    variables: null,
    data: null,
    errors: null,
    from: RequestFrom.NODATA,
    isOutdated: false
};
class KitQLClient {
    constructor(options) {
        var _a, _b;
        const { url, cacheMs, credentials, headers, policy, headersContentType, endpointNetworkDelayMs, endpointSSRDelayMs } = options !== null && options !== void 0 ? options : {};
        this.url = url;
        this.policy = policy !== null && policy !== void 0 ? policy : 'cache-first';
        this.headers = headers !== null && headers !== void 0 ? headers : {};
        this.cacheMs = cacheMs !== null && cacheMs !== void 0 ? cacheMs : 1000 * 60 * 3;
        this.credentials = credentials;
        this.headersContentType = headersContentType !== null && headersContentType !== void 0 ? headersContentType : 'application/graphql+json';
        this.logType = (_a = options.logType) !== null && _a !== void 0 ? _a : [];
        this.cacheData = (_b = options.cacheImplementation) !== null && _b !== void 0 ? _b : new InMemoryCache();
        this.endpointNetworkDelayMs = endpointNetworkDelayMs !== null && endpointNetworkDelayMs !== void 0 ? endpointNetworkDelayMs : 0;
        this.endpointSSRDelayMs = endpointSSRDelayMs !== null && endpointSSRDelayMs !== void 0 ? endpointSSRDelayMs : 0;
        this.log = new Log('KitQL Client');
        this.log.info('This lib was deprecated check https://www.kitql.dev/docs/migrating-to-0.7.0 to upgrade.');
    }
    getHeaders() {
        return this.headers;
    }
    setHeaders(headers) {
        this.headers = headers;
    }
    logOperation(from, operation, variables = null) {
        this.log.info(
        // `${logCyan('Mode:')} ` +
        // 	`${logGreen(browser ? 'browser' : 'server')}, ` +
        `${logCyan('From:')} ${logGreen(from)}, ${new Array(7 - from.length + 1).join(' ')}` +
            `${logCyan('Operation:')} ${logGreen(operation)}` +
            `${variables ? `, ${logCyan('Variables:')} ${logGreen(variables)}` : ``}`);
    }
    getLogsStatements(browser) {
        const browserAndWantLog = browser && this.logType.includes('client');
        const serverAndWantLog = !browser && this.logType.includes('server');
        const logOp = this.logType.includes('operation') && (browserAndWantLog !== null && browserAndWantLog !== void 0 ? browserAndWantLog : serverAndWantLog);
        const logOpVar = this.logType.includes('operationAndvariables') && (browserAndWantLog !== null && browserAndWantLog !== void 0 ? browserAndWantLog : serverAndWantLog);
        const logRawResult = this.logType.includes('rawResult') && (browserAndWantLog !== null && browserAndWantLog !== void 0 ? browserAndWantLog : serverAndWantLog);
        return { logOp, logOpVar, logRawResult };
    }
    requestCache({ variables, operationName, cacheMs, browser }) {
        const logStatements = this.getLogsStatements(browser);
        // No caching in the server for now! (Need to have a session identification to not mix things up)
        if (browser) {
            const cachedData = this.cacheData.get(operationName, variables);
            if (cachedData !== undefined) {
                const xMs = new Date().getTime() - cachedData.date;
                // cache time of the query or of the default config
                if (xMs < (cacheMs !== null && cacheMs !== void 0 ? cacheMs : this.cacheMs)) {
                    if (logStatements.logOpVar) {
                        this.logOperation(RequestFrom.CACHE, operationName, stry(variables, 0));
                    }
                    else if (logStatements.logOp) {
                        this.logOperation(RequestFrom.CACHE, operationName);
                    }
                    return { ...cachedData, from: RequestFrom.CACHE, isOutdated: false };
                }
                return { ...cachedData, from: RequestFrom.CACHE, isOutdated: true };
            }
        }
        return null;
    }
    async request({ skFetch, document, variables, operationName, operationType, browser }) {
        const logStatements = this.getLogsStatements(browser);
        // User help, he is doing wrong
        if (!browser && !skFetch) {
            this.log.error(`I think that either:` +
                `\n\t${logRed(`1/`)} you forgot to provide \`${logYellow(`fetch`)}\`! As we are in SSR here. ` +
                `\n\t   It should be something like:` +
                `\n` +
                `\n\t<script context="module" lang="ts">` +
                `\n\t  export async function load({ ${logYellow(`fetch`)} }) {` +
                `\n\t    ${logYellow('await')} ${logCyan(operationName)}.queryLoad({ ${logYellow(`fetch`)}, variables: { ... } });` +
                `\n\t    return {};` +
                `\n\t  }` +
                `\n\t</script>` +
                `\n` +
                `\n\t${logRed(`2/`)} you should run this in a browser only.`);
        }
        const fetchToUse = skFetch ? skFetch : fetch;
        const dataToReturn = {
            date: new Date().getTime(),
            operationName,
            operationType,
            variables,
            from: RequestFrom.NETWORK,
            data: null,
            errors: null,
            isOutdated: false
        };
        try {
            const res = await fetchToUse(this.url, {
                method: 'POST',
                credentials: this.credentials,
                headers: { ...this.headers, 'Content-Type': this.headersContentType },
                body: JSON.stringify({
                    query: print(document),
                    variables
                })
            });
            if (res.url === '') {
                // In the browser we see a flickering from NETWORK to SSR, because it's the Real SSR coming with a from network... Replaced by the SSR side!
                dataToReturn.from = RequestFrom.SSR;
                await sleep(this.endpointSSRDelayMs); // adding the delay after the request
            }
            else {
                await sleep(this.endpointNetworkDelayMs); // adding the delay after the request
            }
            if (logStatements.logOpVar) {
                this.logOperation(dataToReturn.from, operationName, stry(variables, 0));
            }
            else if (logStatements.logOp) {
                this.logOperation(dataToReturn.from, operationName);
            }
            if (res.status !== 200) {
                if (res.statusText === '') {
                    dataToReturn.errors = [new Error(`${res.status} - ${await res.text()}`)];
                }
                else {
                    dataToReturn.errors = [new Error(`${res.status} - ${res.statusText}`)];
                }
                return dataToReturn;
            }
            const dataJson = await res.json();
            if (logStatements.logRawResult) {
                this.log.info(`${logCyan('dataJson:')} ` + `${stry(dataJson, 0)}`);
            }
            if (dataJson.errors && dataJson.errors.length > 0) {
                dataToReturn.errors = dataJson.errors;
                return dataToReturn;
            }
            dataToReturn.data = dataJson.data;
            // No caching in the server for now! (Need to have a session identification to not mix things up)
            if (browser) {
                this.cacheData.set(operationName, dataToReturn);
            }
            return dataToReturn;
        }
        catch (errors) {
            dataToReturn.errors = [errors];
            return dataToReturn;
        }
    }
    cacheRemove(operationKey, params) {
        const nbDeleted = this.cacheData.remove(operationKey, params.variables, params.allOperationKey);
        this.logInfo(operationKey, 'ResetCache', nbDeleted.toString());
        return nbDeleted;
    }
    logInfo(operationName, key, value) {
        const browserAndWantLog = this.logType.includes('client');
        if (browserAndWantLog) {
            this.log.info(`${logCyan(`${key}:`)} ${logGreen(value)}, ` +
                `${logCyan('Operation:')} ${logGreen(operationName)}`);
        }
    }
    cacheUpdate(operationKey, data, params) {
        const dataCached = this.cacheData.get(operationKey, params.variables);
        if (dataCached) {
            const toReturn = { ...dataCached, data, variables: params.variables };
            this.cacheData.set(operationKey, toReturn);
            return toReturn;
        }
        return undefined;
    }
}

/**
 * Check if on of the stores is in loading state
 * @param stores one or more stores to check
 * @returns true if at least 1 store is in loading state
 */
function isLoading(stores) {
    if (Array.isArray(stores)) {
        return stores.some((store) => store.status === RequestStatus.LOADING);
    }
    return stores.status === RequestStatus.LOADING;
}

export { InMemoryCache, KitQLClient, LocalStorageCache, RequestFrom, RequestStatus, ResponseResultType, defaultStoreValue, isLoading };
