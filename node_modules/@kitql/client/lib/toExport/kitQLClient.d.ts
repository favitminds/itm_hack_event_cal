import type { ICacheData } from './cache/ICacheData';
export declare type ClientSettings<HeadersType extends Record<string, string>> = {
    /**
     * url of your graphql endpoint.
     */
    url: string;
    /**
     * Headers of your requests to graphql endpoint
     * @name headers
     * @default {}
     */
    headers?: HeadersType;
    /**
     * Default Cache in miliseconds
     * @default 3 Minutes (1000 * 60 * 3)
     */
    cacheMs?: number;
    /**
     * @default cache-first
     */
    policy?: Policy;
    /**
     * More info there: https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials
     * @Default omit Secure by default.
     */
    credentials?: Credential;
    /**
     * @Default to `/graphql+json`. But if your server is a bit legacy, you can go back to `/json`
     */
    headersContentType?: HeaderContentType;
    /**
     * @Default [] That means no logs!.
     */
    logType?: LogType[];
    /**
     * @Default InMemory that mean a cache in a variable
     * @description You can provide any implementation of the CacheData interface, it can store the cache in any place
     */
    cacheImplementation?: ICacheData;
    /**
     * @default 0
     * @description endpoint delay in miliseconds. Usefull to simulate slow network by configuration.
     */
    endpointNetworkDelayMs?: number;
    /**
     * @default 0
     * @description endpoint delay in miliseconds. Usefull to simulate slow ssr by configuration.
     */
    endpointSSRDelayMs?: number;
};
export declare type RequestSettings = {
    /**
     * Cache in miliseconds for the Query (so `cache:0` force a network call)
     */
    cacheMs?: number;
    /**
     * overwrite the default cache policy
     */
    policy?: Policy;
};
export declare type Policy = 'cache-first' | 'cache-and-network' | 'network-only' | 'cache-only';
export declare type Credential = 'omit' | 'same-origin' | 'include';
export declare type HeaderContentType = 'application/graphql+json' | 'application/json';
export declare type LogType = 'server' | 'client' | 'operation' | 'operationAndvariables' | 'rawResult';
export declare type PatchType = 'store-only' | 'cache-only' | 'cache-and-store';
export declare type RequestParameters<V> = {
    fetch?: typeof fetch;
    variables?: V;
};
export declare type RequestQueryParameters<V> = {
    settings?: RequestSettings;
} & RequestParameters<V>;
export declare enum RequestStatus {
    'NEVER' = "NEVER",
    'LOADING' = "LOADING",
    'DONE' = "DONE"
}
export declare enum RequestFrom {
    'NODATA' = "NODATA",
    'NETWORK' = "NETWORK",
    'SSR' = "SSR",
    'CACHE' = "CACHE"
}
export declare enum ResponseResultType {
    'Query' = "Query",
    'Mutation' = "Mutation"
}
export declare type ResponseResult<D, V> = {
    date: number;
    operationName: string;
    operationType: ResponseResultType;
    variables?: V;
    data?: D | null;
    errors?: Error[] | null;
    from: RequestFrom;
    isOutdated: boolean;
};
export declare type RequestResult<D, V> = {
    status: RequestStatus;
    isFetching: boolean;
} & ResponseResult<D, V>;
export declare const defaultStoreValue: {
    status: RequestStatus;
    isFetching: boolean;
    date: number;
    operationName: string;
    operationType: ResponseResultType;
    variables: any;
    data: any;
    errors: any;
    from: RequestFrom;
    isOutdated: boolean;
};
export declare class KitQLClient<HeadersType extends Record<string, string>> {
    private url;
    policy: Policy;
    private headers;
    private cacheMs;
    private credentials;
    private headersContentType;
    private logType;
    private cacheData;
    private log;
    private endpointNetworkDelayMs;
    private endpointSSRDelayMs;
    constructor(options: ClientSettings<HeadersType>);
    getHeaders(): HeadersType;
    setHeaders(headers: HeadersType): void;
    private logOperation;
    private getLogsStatements;
    requestCache<D, V>({ variables, operationName, cacheMs, browser }: {
        variables: any;
        operationName: string;
        cacheMs: number | null;
        browser: boolean;
    }): ResponseResult<D, V> | null;
    request<D, V>({ skFetch, document, variables, operationName, operationType, browser }: {
        skFetch: any;
        document: any;
        variables: any;
        operationName: any;
        operationType: any;
        browser: any;
    }): Promise<ResponseResult<D, V>>;
    cacheRemove(operationKey: string, params?: {
        variables?: {} | null;
        allOperationKey?: boolean | null;
    } | null): number;
    logInfo(operationName: string, key: string, value: string): void;
    cacheUpdate<D, V>(operationKey: string, data: D, params?: {
        variables?: V | null;
    } | null): RequestResult<D, V> | undefined;
}
