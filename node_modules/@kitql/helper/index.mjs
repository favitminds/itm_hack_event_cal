function logGreen(str) {
    return `\x1b[32m${str}\x1b[37m\x1b[0m`;
}
function logMagneta(str) {
    return `\x1b[35m${str}\x1b[37m\x1b[0m`;
}
function logRed(str) {
    return `\u001B[31m${str}\x1b[37m\x1b[0m`;
}
function logCyan(str) {
    return `\x1b[36m${str}\x1b[37m\x1b[0m`;
}
function logYellow(str) {
    return `\x1b[33m${str}\x1b[37m\x1b[0m`;
}
class Log {
    constructor(toolName, options = {}) {
        var _a, _b, _c;
        this.toolName = toolName;
        this.levelsToShow = (_a = options.levelsToShow) !== null && _a !== void 0 ? _a : 2;
        this.withDate = (_b = options.withDate) !== null && _b !== void 0 ? _b : null;
        this.prefixEmoji = (_c = options.prefixEmoji) !== null && _c !== void 0 ? _c : '';
    }
    setLevel(logLevel) {
        this.levelsToShow = logLevel;
    }
    buildStr(msg, withError, withSuccess, indent) {
        const table = [];
        table.push(`${logMagneta(`[${this.toolName}]`)}`);
        // DateTime or Time or nothing
        if (this.withDate === 'dateTime') {
            table.push(`${logMagneta(`[${new Date().toISOString()}]`)}`);
        }
        else if (this.withDate === 'time') {
            table.push(`${logMagneta(`[${new Date().toISOString().split('T')[1]}]`)}`);
        }
        // Status icon or prefixEmoji
        if (withError) {
            table.push(`❌`);
        }
        else if (withSuccess) {
            table.push(`✅`);
        }
        else {
            table.push(`${this.prefixEmoji}`);
        }
        table.push(indent);
        table.push(` ${msg}`);
        return table.join('');
    }
    info(msg, conf = { level: 0, withSuccess: false }) {
        var _a, _b;
        const level = (_a = conf.level) !== null && _a !== void 0 ? _a : 0;
        const withSuccess = (_b = conf.withSuccess) !== null && _b !== void 0 ? _b : false;
        if (this.levelsToShow !== null && level <= this.levelsToShow) {
            const indent = ' '.repeat(level);
            console.info(this.buildStr(msg, false, withSuccess, indent));
        }
    }
    success(msg, conf = { level: 0 }) {
        this.info(msg, { level: conf.level, withSuccess: true });
    }
    error(msg) {
        console.error(this.buildStr(msg, true, false, ''));
    }
}

/**
 * Add things to the queryString.
 *
 * Normal usage:
 * ```
 * goto(`?${queryStringApprend($page.url.searchParams, { focus: "Hello" })}`);
 * ```
 * @param searchParams usually: $page.url.searchParams
 * @param queryString an object with key value pairs, something like { focus: "Hello" }
 * @returns a sorted query string
 */
function queryStringApprend(searchParams, queryString) {
    const query = {};
    // 1 Destructure searchParams
    searchParams.forEach((v, k) => {
        query[k] = v;
    });
    // 2 Upset with our queryString
    for (const key in queryString) {
        query[key] = queryString[key];
    }
    // 3 Transform in a table
    const qs = [];
    for (const key in query) {
        qs.push(`${key}=${query[key]}`);
    }
    // 4 send back the Query String
    return qs.sort().join('&');
}

function sortObject(object) {
    const sortedObj = {};
    const keys = Object.keys(object);
    // If there are no keys, the Object was not {}, let's return the object directly
    if (keys.length === 0) {
        return object;
    }
    keys.sort((key1, key2) => {
        (key1 = key1.toLowerCase()), (key2 = key2.toLowerCase());
        if (key1 < key2)
            return -1;
        if (key1 > key2)
            return 1;
        return 0;
    });
    for (const index in keys) {
        const key = keys[index];
        if (typeof object[key] == 'object' && !Array.isArray(object[key]) && object[key]) {
            sortedObj[key] = sortObject(object[key]);
        }
        else {
            sortedObj[key] = object[key];
        }
    }
    return sortedObj;
}
function stry(obj, space = 2) {
    if (obj === null) {
        return null;
    }
    if (obj === undefined) {
        return undefined;
    }
    const ordered = sortObject(obj);
    return JSON.stringify(ordered, null, space);
}

async function sleep(ms) {
    if (ms <= 0) {
        return;
    }
    return new Promise(resolve => setTimeout(resolve, ms));
}

export { Log, logCyan, logGreen, logMagneta, logRed, logYellow, queryStringApprend, sleep, stry };
